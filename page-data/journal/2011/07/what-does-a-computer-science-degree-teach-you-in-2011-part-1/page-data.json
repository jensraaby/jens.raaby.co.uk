{"componentChunkName":"component---src-templates-post-template-js","path":"/journal/2011/07/what-does-a-computer-science-degree-teach-you-in-2011-part-1","result":{"data":{"markdownRemark":{"id":"cdcd1042-5af3-595b-af2b-8bb03644ff2d","html":"<p>Last Friday was the end of my university degree. I left school in 2007 and went straight to the University of York, which at the time was widely regarded as a top 5 Computer Science department.</p>\n<p>I had 5 offers to choose between and while York might not have been the highest (Imperial College) or lowest (St. Andrews), it struck a good balance for me. London was a bit too expensive and Scotland too far away, and my other offers were from universities which didn’t rank as highly.</p>\n<p>I thought it would be useful to go through the course retrospectively to give an idea of what I have been taught and what options I had. This first post looks at the first year.<!-- more --></p>\n<h3 id=\"the-first-year\" style=\"position:relative;\"><a href=\"#the-first-year\" aria-label=\"the first year permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>The first year</h3>\n<p>On arrival to most Computer Science (CS) courses you are not expected to have any prior experience of the subject. Some students had taken A level Computing which is as close as it gets, but I had never been taught programming let alone had an IT lesson since the age of 11. My experience was mostly in web development which is still something I do on a freelance basis, but does not really compare to ‘real’ programming.</p>\n<p>The course has now been completely restructured, and some of this year’s graduates even had a different first year to me (Java is now used instead of Ada).</p>\n<p>The first term consisted of 4 introductory modules. These introduced the strands that were continued in the Spring to a more advanced level. Our first programming module (POP) was certainly a lot of fun. For those with more programming experience it was a little frustrating that they had to use a language with so little syntax other than brackets and unusual notation. Scheme (a LISP variant) still brings back fond memories to those of us who enjoyed that course, and who could forget a lecturer who launched a remote control space craft in lectures on object orientation?</p>\n<p>The first maths module taught discrete mathematics and propositional logic, and this tended to polarise opinions (a lot of CS students I know openly dislike maths) but everyone enjoyed the lectures. This module was taught by an <a href=\"http://www-users.cs.york.ac.uk/~colin/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">excellent lecturer</a>, who is deeply involved in functional programming (Haskell). It was the most challenging first-term module in terms of thought required, but definitely worthwhile.</p>\n<p>Our other introductory modules centred around digital circuit design (IDD) and general computer systems background (ICS). ICS taught us the basics of the Unix/Linux command line and some simple scripting, as well as discussing computer architecture and floating point representation (IEEE754 is the only standard I can remember by number).</p>\n<p>IDD was my first and last failure in my degree. I liked that York taught both hardware and software, but when it came to it I don’t think I am the right sort of person to work on hardware. I understood the Karnaugh maps and principles of all the logic gates but didn’t work hard enough on this module and failed it by 3.5 marks.</p>\n<p><strong>After the first round of January exams we continued with more advanced modules on the same strands.</strong></p>\n<p>The programming strand continued as Algorithms and Data Structures (ADS), a course which split its time between theory (complexity, analysis, trees, maps - the things that interviewers expect you to know to a certain extent) and practice. We were exposed to a ‘Marmite’ langauge - Ada. This was devised by the US DoD with type safety and lots of frustration after the freedom of Scheme. It really did teach good discipline in my opinion; with every variable and procedure being explicitly typed, with specific input and output constraints, the code you wrote (or were forced to write by the compiler, depending on how you see things) was good quality and excellent training and it’s a shame the subsequent year groups moved over to Java instead. This is the module where I spent the most time documenting code, and I wish I had kept to the style I used back then as I progressed through the course. (That’s not to say I no longer document things, but I don’t do it as thoroughly - maybe I do save lots of time not documenting the obvious things now). The ADS open assessments (coursework) involved parsing text files to data structures and performing analysis - this put into use the theory component of the course. The <a href=\"http://www-users.cs.york.ac.uk/~jeremy/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">theory lecturer</a> was a particularly thorough teacher who read stories from Dijkstra and was supervised by the inventor of QuickSort, C.A.R. Hoare. It was certainly my favourite module that term, in particular compared with the hardware strand.</p>\n<p>The dent in my confidence after the first hardware module was not made any better by learning analogue electronics in the summer term. This took away all the nice boolean logic and replaced it with more tenuous concepts and techniques which I ought to have paid more attention to, as this part of the exam was incredibly tough. The digital design component was better, and I managed to build my own traffic light logic, although my lab partner quit the course half way through the term. My logbook documenting the design and testing of each mini-project accounted for 20% of the marks for the module and it saved my bacon. When given the choice between hardware and software for my second year, my decision was based on my bad track record in analogue electronics and the first electronics module. This prevented me changing to the Masters version of the course later on, so in hindsight I should have carefully considered this option. (The second year hardware modules involved programming a Z80 chip and doing lots of cool things which in some cases ended up with smoke.)</p>\n<p>The computer systems strand continued with coverage of computer architectures and their history. One part of the course focussed very much on the components of a CPU needed to support basic instruction sets, in particular with a stack machine architecture. The other half of the course, with <a href=\"http://www.cs.york.ac.uk/arch/staff/permanent/Austin\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">one of the most enthusiastic lecturers I’ve ever come across</a>, covered the development of computer architectures from mechanical machines to modern Intel designs. It was very enjoyable, although it was the least practical module of the summer and therefore I don’t feel I got as much out of it as some of the other courses.</p>\n<p>The final strand of the first year was maths, with the ‘Mathematics for Computer Science’ (MCS) module. When I was at school, maths was one of my strong points. I somehow managed to impress my teachers enough to win a maths prize two years in a row, but I was not so good at the subject when under pressure in exams, despite enjoying the subject. MCS was divide in two - the first half tried to teach us A level concepts in a new way, with different notation and various pitfalls. I thought I would enjoy that part, but the other half was more interesting. We were introduced to the theory of computation in this module, moving from simple state machines up to pushdown stack automata. This was a very interesting subject for me and while challenging it has clarified what distinguishes Computer Science from Software Engineering to a certain extent.</p>\n<p>So, that was year 1. It wasn’t my best year in terms of academic performance. I was tired of exams by the time I started at university; my school had them every year and A levels were quite challenging (such as having 4 exams on one day, along with others the same week). My advice for younger computer science students will come in a later post once I have finished this series.</p>","fields":{"slug":"/journal/2011/07/what-does-a-computer-science-degree-teach-you-in-2011-part-1","tagSlugs":null},"frontmatter":{"date":"2011-07-06T09:10:10.000Z","description":"In which I try to cover my first year of Computer Science","tags":null,"title":"What does a Computer Science degree teach you in 2011?","socialImage":null}}},"pageContext":{"slug":"/journal/2011/07/what-does-a-computer-science-degree-teach-you-in-2011-part-1"}}}